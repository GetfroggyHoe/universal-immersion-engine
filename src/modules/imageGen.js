import { getSettings, saveSettings } from "./core.js";
import { notify } from "./notifications.js";
import { generateContent } from "./apiClient.js";

let uieImgCsrfCache = { t: 0, token: "" };
let comfyWorkflowCache = { raw: "", parsed: null, ids: null, err: "", at: 0 };

function safeStructuredClone(v) {
    try {
        if (typeof structuredClone === "function") return structuredClone(v);
    } catch (_) {}
    return JSON.parse(JSON.stringify(v));
}

function parseComfyWorkflowRaw(workflowRaw) {
    const obj = JSON.parse(String(workflowRaw || ""));
    if (obj && typeof obj === "object" && obj.prompt && typeof obj.prompt === "object") return obj.prompt;
    return obj;
}

function detectComfyNodeIds(graph) {
    const g = graph && typeof graph === "object" ? graph : {};
    const clip = [];
    const save = [];
    const preview = [];
    for (const [id, n] of Object.entries(g)) {
        const ct = String(n?.class_type || "");
        if (/CLIPTextEncode/i.test(ct)) clip.push(id);
        if (/SaveImage/i.test(ct)) save.push(id);
        if (/PreviewImage/i.test(ct)) preview.push(id);
    }
    const positiveNodeId = clip.length ? String(clip[0]) : "";
    const negativeNodeId = clip.length > 1 ? String(clip[1]) : "";
    const outputNodeId = save.length ? String(save[0]) : preview.length ? String(preview[0]) : "";
    return { positiveNodeId, negativeNodeId, outputNodeId };
}

function buildDefaultComfyWorkflowJson() {
    return JSON.stringify({
        "3": {
            class_type: "KSampler",
            inputs: {
                cfg: "%scale%",
                denoise: "%denoise%",
                latent_image: ["5", 0],
                model: ["4", 0],
                negative: ["7", 0],
                positive: ["6", 0],
                sampler_name: "%sampler%",
                scheduler: "%scheduler%",
                seed: "%seed%",
                steps: "%steps%"
            }
        },
        "4": { class_type: "CheckpointLoaderSimple", inputs: { ckpt_name: "%model%" } },
        "5": { class_type: "EmptyLatentImage", inputs: { batch_size: 1, height: "%height%", width: "%width%" } },
        "6": { class_type: "CLIPTextEncode", inputs: { clip: ["4", 1], text: "%prompt%" } },
        "7": { class_type: "CLIPTextEncode", inputs: { clip: ["4", 1], text: "%negative_prompt%" } },
        "8": { class_type: "VAEDecode", inputs: { samples: ["3", 0], vae: ["4", 2] } },
        "9": { class_type: "SaveImage", inputs: { filename_prefix: "UIE", images: ["8", 0] } }
    });
}

function makeSvgFallbackDataUrl(promptText, reason) {
    const safePrompt = String(promptText || "Image generated by UIE").slice(0, 180);
    const safeReason = String(reason || "Fallback renderer").slice(0, 120);
    const esc = (s) => String(s)
        .replace(/&/g, "&amp;")
        .replace(/</g, "&lt;")
        .replace(/>/g, "&gt;")
        .replace(/"/g, "&quot;");
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="1024" height="1024" viewBox="0 0 1024 1024">
<defs><linearGradient id="g" x1="0" y1="0" x2="1" y2="1"><stop offset="0%" stop-color="#1d2233"/><stop offset="100%" stop-color="#111827"/></linearGradient></defs>
<rect width="1024" height="1024" fill="url(#g)"/>
<rect x="64" y="64" width="896" height="896" rx="24" fill="none" stroke="#7dd3fc" stroke-opacity="0.45" stroke-width="3"/>
<text x="80" y="128" fill="#e5e7eb" font-family="Arial, sans-serif" font-size="36" font-weight="700">UIE Image Fallback</text>
<text x="80" y="182" fill="#9ca3af" font-family="Arial, sans-serif" font-size="22">${esc(safeReason)}</text>
<foreignObject x="80" y="230" width="864" height="700">
  <div xmlns="http://www.w3.org/1999/xhtml" style="color:#d1d5db;font-family:Arial,sans-serif;font-size:28px;line-height:1.35;white-space:pre-wrap;">${esc(safePrompt)}</div>
</foreignObject>
</svg>`;
    return `data:image/svg+xml;charset=utf-8,${encodeURIComponent(svg)}`;
}

function applyComfySettings(graph, { checkpoint, sampler, scheduler, steps, cfg, denoise, seed, width, height }) {
    const g = graph && typeof graph === "object" ? graph : graph;
    try {
        for (const n of Object.values(g || {})) {
            const ct = String(n?.class_type || "");
            if (!n || typeof n !== "object") continue;
            if (!n.inputs || typeof n.inputs !== "object") n.inputs = {};

            if (/CheckpointLoaderSimple/i.test(ct) && checkpoint) {
                if ("ckpt_name" in n.inputs || n.inputs.ckpt_name === undefined) n.inputs.ckpt_name = String(checkpoint);
            }
            if (/KSampler/i.test(ct)) {
                if (sampler && ("sampler_name" in n.inputs || n.inputs.sampler_name === undefined)) n.inputs.sampler_name = String(sampler);
                if (scheduler && ("scheduler" in n.inputs || n.inputs.scheduler === undefined)) n.inputs.scheduler = String(scheduler);
                if (Number.isFinite(steps) && steps > 0 && ("steps" in n.inputs || n.inputs.steps === undefined)) n.inputs.steps = steps;
                if (Number.isFinite(cfg) && cfg >= 0 && ("cfg" in n.inputs || n.inputs.cfg === undefined)) n.inputs.cfg = cfg;
                if (Number.isFinite(denoise) && denoise >= 0 && denoise <= 1 && ("denoise" in n.inputs || n.inputs.denoise === undefined)) n.inputs.denoise = denoise;
                if (Number.isFinite(seed) && seed >= 0 && ("seed" in n.inputs || n.inputs.seed === undefined)) n.inputs.seed = seed;
            }
            if (/EmptyLatentImage/i.test(ct)) {
                if (Number.isFinite(width) && width > 0 && ("width" in n.inputs || n.inputs.width === undefined)) n.inputs.width = width;
                if (Number.isFinite(height) && height > 0 && ("height" in n.inputs || n.inputs.height === undefined)) n.inputs.height = height;
            }
        }
    } catch (_) {}
    return g;
}

async function getCsrfToken() {
    const now = Date.now();
    if (uieImgCsrfCache.token && now - uieImgCsrfCache.t < 5 * 60 * 1000) return uieImgCsrfCache.token;
    try {
        const r = await fetch("/csrf-token", { method: "GET" });
        if (!r.ok) return "";
        const j = await r.json().catch(() => null);
        const tok = String(j?.csrfToken || j?.token || "").trim();
        if (tok) uieImgCsrfCache = { t: now, token: tok };
        return tok;
    } catch (_) {
        return "";
    }
}

function buildCorsProxyCandidates(targetUrl) {
    const u = String(targetUrl || "").trim();
    if (!u) return [];
    const enc = encodeURIComponent(u);
    const out = [];
    const add = (x) => { if (x && !out.includes(x)) out.push(x); };
    // Standard ST Proxy (often accepts url param)
    add(`/api/proxy?url=${enc}`);
    add(`/proxy?url=${enc}`);
    // Common alternatives
    add(`/api/cors-proxy?url=${enc}`);
    add(`/cors-proxy?url=${enc}`);
    add(`/api/extra/proxy?url=${enc}`);

    // Direct path proxying (some setups)
    add(`/api/proxy/${enc}`);

    // Fallback: simple echo (unlikely to work for complex posts but worth a shot for GET)
    return out;
}

function isFailedToFetchError(e) {
    const m = String(e?.message || e || "").toLowerCase();
    return m.includes("failed to fetch") || m.includes("networkerror") || m.includes("load failed") || m.includes("cors") || m.includes("forbidden");
}

async function fetchWithCorsProxyFallback(targetUrl, options, opts = {}) {
    const skipDirect = opts.skipDirect === true;
    const isLocalHost = /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0)(:\d+)?(\/|$)/i.test(String(targetUrl || ""));

    const tryServerForward = async (endpoint) => {
        try {
            const targetHdr = new Headers(options?.headers || {});
            const hdr = new Headers();
            hdr.set("Content-Type", "application/json");
            const payload = {
                url: String(targetUrl || ""),
                method: String(options?.method || "GET"),
                headers: Object.fromEntries(targetHdr.entries()),
                body: typeof options?.body === "string" ? options.body : (options?.body != null ? JSON.stringify(options.body) : null)
            };
            const tok = await getCsrfToken();
            if (tok && !hdr.has("X-CSRF-Token")) hdr.set("X-CSRF-Token", tok);
            const r = await fetch(String(endpoint || ""), { method: "POST", headers: hdr, body: JSON.stringify(payload), credentials: "same-origin" });
            if (!r.ok) return null;
            return r;
        } catch (_) {
            return null;
        }
    };

    const runProxyFallback = async (lastErr) => {
        const candidates = buildCorsProxyCandidates(targetUrl);
        for (const ep of ["/api/forward", "/api/proxy", "/api/extra/proxy", "/api/cors-proxy", "/api/corsProxy"]) {
            const r = await tryServerForward(ep);
            if (r) return { response: r, via: "server-forward", requestUrl: ep };
        }
        for (const proxyUrl of candidates) {
            try {
                const r = await fetch(proxyUrl, options);
                if (r.status === 404 || r.status === 405 || (r.status >= 500 && r.status <= 599)) continue;
                if (r.status === 403 || r.status === 401) {
                    const tok = await getCsrfToken();
                    if (tok) {
                        const h = new Headers(options?.headers || {});
                        if (!h.has("X-CSRF-Token")) h.set("X-CSRF-Token", tok);
                        const r2 = await fetch(proxyUrl, { ...options, headers: h });
                        if (r2.status === 404 || r2.status === 405 || (r2.status >= 500 && r2.status <= 599)) continue;
                        return { response: r2, via: "proxy", requestUrl: proxyUrl };
                    }
                }
                return { response: r, via: "proxy", requestUrl: proxyUrl };
            } catch (e2) {
                lastErr = e2;
                continue;
            }
        }
        throw lastErr;
    };

    if (skipDirect || (isLocalHost && (options?.method || "GET") === "POST")) {
        return await runProxyFallback(new Error("Skipped direct (local/CORS)"));
    }

    try {
        const r = await fetch(targetUrl, options);
        if (r.status === 403 || r.status === 404) {
            throw new Error("CORS/Forbidden");
        }
        return { response: r, via: "direct", requestUrl: targetUrl };
    } catch (e) {
        if (!isFailedToFetchError(e) && !skipDirect) throw e;
        return await runProxyFallback(e);
    }
}

function normalizeEndpoint(x) {
    x = String(x || "").trim().replace(/\/+$/, "");
    if (/\/api\/v1$/i.test(x)) return `${x}/images/generations`;
    if (/\/v1$/i.test(x)) return `${x}/images/generations`;
    return x;
}

/**
 * Checks if an image should be generated based on context, then generates it.
 * @param {string} context - The text content (chat, item desc, etc.)
 * @param {string} feature - The feature key (map, doll, social, phoneBg, msg, party, items)
 * @returns {Promise<string|null>} - The image URL or null
 */
export async function checkAndGenerateImage(context, feature) {
    const s = getSettings();
    if (!s.image || !s.image.enabled) return null;
    if (s.image.features && s.image.features[feature] === false) return null;

    // 1. Ask AI if we need a photo
    const checkPrompt = `
Context: ${context.slice(0, 1000)}
Question: Does this context explicitly describe a visual scene, item, or character that needs a photo?
Answer (Yes/No):`;

    const checkRes = await generateContent(checkPrompt, "System Image Check");

    if (!checkRes) return null;
    const answer = String(checkRes).trim().toLowerCase();

    // Strict check for "yes"
    if (!answer.startsWith("yes")) return null;

    // 2. Generate the Image Prompt
    const promptGenPrompt = `
Context: ${context.slice(0, 2000)}
Task: Create a highly detailed, strict image generation prompt for DALL-E 3 based on the context.
Include style details (fantasy, realistic, etc) appropriate for the setting.
Return ONLY the prompt text.`;

    const imagePrompt = await generateContent(promptGenPrompt, "System Image Prompt");
    if (!imagePrompt) return null;

    // 3. Call Image API
    return await generateImageAPI(imagePrompt);
}

// --- PAYWALL HANDLER ---
function handleNanoPayment(data) {
    // Find Nano option
    const nano = data.accepts?.find(x => x.scheme === "nano" || x.network === "nano-mainnet");
    if (!nano) return;

    const amount = nano.maxAmountRequiredFormatted || "0.193 XNO";
    const address = nano.payTo;
    const usd = nano.maxAmountRequiredUSD || "0.00";

    // Create Modal
    const id = "uie-pay-modal";
    $(`#${id}`).remove();

    const qrUrl = `https://api.qrserver.com/v1/create-qr-code/?size=150x150&data=${encodeURIComponent(`nano:${address}?amount=${nano.maxAmountRequired}`)}`;

    const html = `
    <div id="${id}" style="position:fixed; inset:0; z-index:2147483660; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center;">
        <div style="background:#1a1a1a; border:1px solid #f1c40f; padding:20px; border-radius:12px; width:min(400px, 90vw); color:#fff; text-align:center; font-family:sans-serif;">
            <h3 style="color:#f1c40f; margin-top:0;">Payment Required</h3>
            <div style="font-size:0.9em; color:#ccc; margin-bottom:15px;">
                NanoGPT requires a micro-payment for this request.
            </div>

            <div style="background:#fff; padding:10px; display:inline-block; border-radius:8px; margin-bottom:15px;">
                <img src="${qrUrl}" alt="QR Code" style="display:block; width:150px; height:150px;">
            </div>

            <div style="font-weight:bold; font-size:1.1em; margin-bottom:5px;">${amount}</div>
            <div style="font-size:0.8em; color:#888; margin-bottom:15px;">(approx $${usd})</div>

            <div style="background:#222; padding:10px; border-radius:6px; word-break:break-all; font-family:monospace; font-size:0.85em; user-select:all; border:1px solid #444; margin-bottom:15px; cursor:pointer;" onclick="navigator.clipboard.writeText('${address}'); toastr.success('Copied Address');">
                ${address}
            </div>

            <div style="font-size:0.8em; color:#aaa; margin-bottom:20px;">
                Send exactly this amount to continue. The request will retry automatically or you can close this and try again.
            </div>

            <button onclick="$('#${id}').remove()" style="background:#333; border:1px solid #555; color:#fff; padding:8px 20px; border-radius:6px; cursor:pointer;">Close</button>
        </div>
    </div>
    `;

    $("body").append(html);
}

/**
 * Direct call to Image API
 */
export async function generateImageAPI(prompt) {
    const s = getSettings();
    const img = s.image || {};
    const endpoint = normalizeEndpoint(String(img.url || "https://api.openai.com/v1/images/generations"));
    const provider = String(img.provider || "").toLowerCase();
    const model = String(img.model || "dall-e-3").trim();
    const apiKey = String(img.key || "").trim();
    const negText = String(img.negativePrompt || "").trim();

    const isLocal = /^https?:\/\/(localhost|127\.0\.0\.1|0\.0\.0\.0)(:\d+)?(\/|$)/i.test(endpoint);
    const isPollinations = provider === "pollinations";
    const isSdWebUi = provider === "sdwebui" || /\/sdapi\/v1\/txt2img\s*$/i.test(endpoint);
    const isComfy = (() => {
        if (provider === "comfy") return true;
        if (isSdWebUi) return false;
        if (/\/v1\/images\/generations\s*$/i.test(endpoint)) return false;
        if (/\/images\/generations\s*$/i.test(endpoint)) return false;
        if (/\/prompt\s*$/i.test(endpoint)) return true;
        if (/:(8188|8189)(\/|$)/i.test(endpoint)) return true;
        const wf = String(img?.comfy?.workflow || "").trim();
        return !!wf && isLocal;
    })();

    if (window.toastr) toastr.info("Generating Image...", "AI Fabricator");

    const rawPrompt = String(prompt || "");
    const lockedPrompt = /^\[UIE_LOCKED\]/i.test(rawPrompt.trim());
    let finalPrompt = rawPrompt.replace(/^\s*\[UIE_LOCKED\]\s*/i, "").trim();

    if (!lockedPrompt) {
        try {
            const p = s?.generation?.promptPrefixes || {};
            const global = String(p?.global || "").trim();
            if (global) finalPrompt = `${global}, ${finalPrompt}`;
        } catch (_) {}
    }

    const startedAt = Date.now();
    const pollinationsFallback = async (reason) => {
        const fallbackReason = String(reason || "Primary provider unavailable");
        try {
            const pollUrl = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt || "fantasy concept art")}?nologo=true&width=1024&height=1024&seed=${Math.floor(Math.random() * 100000)}`;
            const fx = await fetchWithCorsProxyFallback(pollUrl, { method: "GET" }, { skipDirect: false });
            if (!fx?.response?.ok) throw new Error(`Pollinations fallback failed (${fx?.response?.status || 0})`);
            const blob = await fx.response.blob();
            const dataUrl = await new Promise(resolve => {
                const r = new FileReader();
                r.onload = () => resolve(r.result);
                r.readAsDataURL(blob);
            });
            try {
                window.UIE_lastImage = {
                    ok: true,
                    ms: Date.now() - startedAt,
                    endpoint: "pollinations",
                    mode: "fallback-pollinations",
                    reason: fallbackReason.slice(0, 120)
                };
            } catch (_) {}
            try { window.toastr?.warning?.("Primary image API failed, used fallback renderer."); } catch (_) {}
            return dataUrl;
        } catch (e) {
            const svgOut = makeSvgFallbackDataUrl(finalPrompt, fallbackReason);
            try {
                window.UIE_lastImage = {
                    ok: true,
                    ms: Date.now() - startedAt,
                    endpoint: "uie:svg-fallback",
                    mode: "fallback-svg",
                    error: String(e?.message || e || "Fallback failed").slice(0, 160),
                    reason: fallbackReason.slice(0, 120)
                };
            } catch (_) {}
            try { window.toastr?.warning?.("All image APIs failed, used local fallback image."); } catch (_) {}
            return svgOut;
        }
    };

    if (!apiKey && !isLocal && !isSdWebUi && !isComfy && !isPollinations) {
        console.warn("Image Gen: Missing API key, switching to fallback.");
        return await pollinationsFallback("Missing API key");
    }

    try {
        if (isPollinations) {
            const url = `https://image.pollinations.ai/prompt/${encodeURIComponent(finalPrompt)}?nologo=true&width=1024&height=1024&seed=${Math.floor(Math.random() * 100000)}`;
            const fx = await fetchWithCorsProxyFallback(url, { method: "GET" });
            if (!fx.response.ok) throw new Error("Pollinations API failed");
            const blob = await fx.response.blob();
            const dataUrl = await new Promise(resolve => {
                const r = new FileReader();
                r.onload = () => resolve(r.result);
                r.readAsDataURL(blob);
            });
            try { window.UIE_lastImage = { ok: true, ms: Date.now() - startedAt, endpoint: "pollinations", mode: "pollinations" }; } catch (_) {}
            return dataUrl;
        }

        if (isComfy) {
            const comfyBase = String(img?.comfy?.base || "").trim();
            const comfyKey = String(img?.comfy?.key || "").trim();
            const endpoint2 = comfyBase || endpoint;

            // Check if endpoint is local (127.0.0.1 or localhost)
            // If it is, we should assume SillyTavern's backend can reach it and try to proxy
            // to avoid CORS issues if the user is accessing ST from a different IP/domain.
            const isLocalTarget = /localhost|127\.0\.0\.1|0\.0\.0\.0/.test(endpoint2);

            let wfRaw = String(img?.comfy?.workflow || "").trim();
            if (!wfRaw) {
                wfRaw = buildDefaultComfyWorkflowJson();
                try {
                    if (!s.image) s.image = {};
                    if (!s.image.comfy) s.image.comfy = {};
                    s.image.comfy.workflow = wfRaw;
                    saveSettings();
                } catch (_) {}
            }

            let ids = null;
            try {
                const baseGraph = parseComfyWorkflowRaw(wfRaw);
                ids = detectComfyNodeIds(baseGraph);
            } catch (_) {}

            // For local ComfyUI always use proxy-first to avoid CORS/403 from browser
            const useProxy = isLocalTarget;

            const out = await generateComfyUI({
                endpoint: endpoint2,
                workflowRaw: wfRaw,
                promptText: finalPrompt,
                negativePrompt: negText,
                checkpoint: String(img?.comfy?.checkpoint || "").trim(),
                positiveNodeId: String(img?.comfy?.positiveNodeId || "").trim() || String(ids?.positiveNodeId || ""),
                negativeNodeId: String(img?.comfy?.negativeNodeId || "").trim() || String(ids?.negativeNodeId || ""),
                outputNodeId: String(img?.comfy?.outputNodeId || "").trim() || String(ids?.outputNodeId || ""),
                apiKey: comfyKey,
                forceProxy: useProxy
            });
            try { window.UIE_lastImage = { ok: !!out, ms: Date.now() - startedAt, endpoint: endpoint2, mode: "comfy" }; } catch (_) {}
            if (out) return out;
            return await pollinationsFallback("ComfyUI returned no image");
        }

        if (isSdWebUi) {
            const sdUrl = String(img.sdwebuiUrl || endpoint).trim();
            const payload = {
                prompt: finalPrompt,
                negative_prompt: negText,
                steps: 20,
                width: 512,
                height: 512,
                cfg_scale: 7
            };
            const fx = await fetchWithCorsProxyFallback(sdUrl, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload)
            });
            const res = fx.response;
            if (!res.ok) {
                const err = await res.text();
                try { window.UIE_lastImage = { ok: false, ms: Date.now() - startedAt, endpoint: sdUrl, mode: "sdwebui", status: res.status, error: String(err || "").slice(0, 280) }; } catch (_) {}
                return await pollinationsFallback(`SDWebUI error ${res.status}`);
            }
            const data = await res.json();
            const imgB64 = Array.isArray(data?.images) ? String(data.images[0] || "") : "";
            if (!imgB64) return await pollinationsFallback("SDWebUI returned empty image");
            const out = imgB64.startsWith("data:image") ? imgB64 : `data:image/png;base64,${imgB64}`;
            try { window.UIE_lastImage = { ok: true, ms: Date.now() - startedAt, endpoint: sdUrl, mode: "sdwebui", status: 200 }; } catch (_) {}
            return out;
        }

        const headers = { "Content-Type": "application/json", "Accept": "application/json" };
        if (apiKey) headers.Authorization = `Bearer ${apiKey}`;
        const fx = await fetchWithCorsProxyFallback(endpoint, {
            method: "POST",
            headers,
            body: JSON.stringify({ model, prompt: finalPrompt, n: 1, size: "1024x1024", response_format: "url" })
        });
        const res = fx.response;

        if (res.status === 402) {
            try {
                const data = await res.json();
                handleNanoPayment(data);
            } catch (_) {}
            if (window.toastr) toastr.warning("Payment Required");
            return await pollinationsFallback("Upstream payment required");
        }

        if (!res.ok) {
            const err = await res.text();
            console.error("Image Gen Error:", err);
            try { window.UIE_lastImage = { ok: false, ms: Date.now() - startedAt, endpoint, mode: "openai", status: res.status, error: String(err || "").slice(0, 280), via: fx?.via || "" }; } catch (_) {}
            return await pollinationsFallback(`Image API error ${res.status}`);
        }

        const data = await res.json();
        const first = Array.isArray(data?.data) ? data.data[0] : null;
        const urlOut = String(first?.url || data?.url || "").trim();
        const b64 = String(first?.b64_json || first?.b64 || "").trim();
        if (urlOut) return urlOut;
        if (b64) return b64.startsWith("data:image") ? b64 : `data:image/png;base64,${b64}`;
        return await pollinationsFallback("Image API returned no image payload");
    } catch (e) {
        const msg = String(e?.message || e || "Image gen failed");
        try { console.error("Image Gen Exception:", { message: msg, endpoint, stack: String(e?.stack || "").slice(0, 3000) }); } catch (_) { console.error("Image Gen Exception:", msg); }
        try { notify("error", "Image Gen Error: " + msg.slice(0, 220), "UIE", "api"); } catch (_) {}
        try { window.UIE_lastImage = { ok: false, ms: 0, endpoint, mode: isComfy ? "comfy" : isSdWebUi ? "sdwebui" : "openai", status: 0, error: msg.slice(0, 280) }; } catch (_) {}
        return await pollinationsFallback(msg);
    }
}

async function generateComfyUI({ endpoint, workflowRaw, promptText, negativePrompt, checkpoint, positiveNodeId, negativeNodeId, outputNodeId, apiKey, forceProxy }) {
    const s = getSettings();
    const comfy = s?.image?.comfy && typeof s.image.comfy === "object" ? s.image.comfy : {};
    const ez = comfy?.easy && typeof comfy.easy === "object" ? comfy.easy : {};

    const common = String(comfy?.common || "").trim();
    const commonNeg = String(comfy?.commonNeg || "").trim();
    if (common) promptText = `${common}\n${String(promptText || "")}`.trim();
    if (commonNeg) negativePrompt = `${commonNeg}\n${String(negativePrompt || "")}`.trim();

    const numOrNull = (v) => {
        const n = typeof v === "string" && v.trim() === "" ? NaN : Number(v);
        return Number.isFinite(n) ? n : null;
    };

    const steps = numOrNull(ez.steps);
    const cfg = numOrNull(ez.cfg);
    const denoise = numOrNull(ez.denoise);
    const width = numOrNull(ez.width);
    const height = numOrNull(ez.height);
    const seedIn = numOrNull(ez.seed);
    const seed = Number.isFinite(seedIn) && seedIn >= 0 ? seedIn : Math.floor(Math.random() * 1e9);

    const sampler = String(comfy.sampler || "").trim();
    const scheduler = String(comfy.scheduler || "").trim();
    checkpoint = String(checkpoint || comfy.checkpoint || "").trim();

    try {
        if (comfyWorkflowCache.raw !== String(workflowRaw || "") || !comfyWorkflowCache.parsed) {
            const parsed = parseComfyWorkflowRaw(workflowRaw);
            comfyWorkflowCache = {
                raw: String(workflowRaw || ""),
                parsed,
                ids: detectComfyNodeIds(parsed),
                err: "",
                at: Date.now()
            };
        }
    } catch (e) {
        comfyWorkflowCache = { raw: String(workflowRaw || ""), parsed: null, ids: null, err: String(e?.message || e || ""), at: Date.now() };
    }

    const baseGraph = comfyWorkflowCache.parsed;
    if (!baseGraph) return null;

    const ids = comfyWorkflowCache.ids || {};
    if (!positiveNodeId) positiveNodeId = String(ids.positiveNodeId || "");
    if (!negativeNodeId) negativeNodeId = String(ids.negativeNodeId || "");
    if (!outputNodeId) outputNodeId = String(ids.outputNodeId || "");

    const normalizeBase = (u) => String(u || "").trim().replace(/\/+$/, "").replace(/\/prompt$/i, "");
    const base = normalizeBase(endpoint);
    const promptUrl = `${base}/prompt`;
    const viewUrl = `${base}/view`;
    const historyUrl = `${base}/history`;

    const deepReplace = (v) => {
        if (typeof v === "string") {
            return v
                .replace(/\{\{\s*(prompt|positive_prompt|positive)\s*\}\}/gi, String(promptText || ""))
                .replace(/\{\{\s*(negative_prompt|negative)\s*\}\}/gi, String(negativePrompt || ""))
                .replace(/\{\{\s*(checkpoint|ckpt|model)\s*\}\}/gi, String(checkpoint || ""))
                .replace(/\{\{\s*(width|w)\s*\}\}/gi, width === null ? "{{width}}" : String(width))
                .replace(/\{\{\s*(height|h)\s*\}\}/gi, height === null ? "{{height}}" : String(height))
                .replace(/\{\{\s*(size|resolution)\s*\}\}/gi, (width === null || height === null) ? "{{size}}" : `${width}x${height}`)
                .replace(/\{\{\s*(steps)\s*\}\}/gi, steps === null ? "{{steps}}" : String(steps))
                .replace(/\{\{\s*(scale|cfg|cfg_scale)\s*\}\}/gi, cfg === null ? "{{scale}}" : String(cfg))
                .replace(/\{\{\s*(denoise|denoising)\s*\}\}/gi, denoise === null ? "{{denoise}}" : String(denoise))
                .replace(/\{\{\s*(sampler)\s*\}\}/gi, String(sampler || ""))
                .replace(/\{\{\s*(scheduler)\s*\}\}/gi, String(scheduler || ""))
                .replace(/\{\{\s*(seed)\s*\}\}/gi, String(seed))
                .replace(/%prompt%/gi, String(promptText || ""))
                .replace(/%negative_prompt%/gi, String(negativePrompt || ""))
                .replace(/%model%/gi, String(checkpoint || ""))
                .replace(/%sampler%/gi, String(sampler || ""))
                .replace(/%scheduler%/gi, String(scheduler || ""))
                .replace(/%steps%/gi, steps === null ? "%steps%" : String(steps))
                .replace(/%scale%/gi, cfg === null ? "%scale%" : String(cfg))
                .replace(/%denoise%/gi, denoise === null ? "%denoise%" : String(denoise))
                .replace(/%width%/gi, width === null ? "%width%" : String(width))
                .replace(/%height%/gi, height === null ? "%height%" : String(height))
                .replace(/%size%/gi, (width === null || height === null) ? "%size%" : `${width}x${height}`)
                .replace(/%seed%/gi, String(seed));
        }
        if (Array.isArray(v)) return v.map(deepReplace);
        if (v && typeof v === "object") {
            const out = {};
            for (const [k, val] of Object.entries(v)) out[k] = deepReplace(val);
            return out;
        }
        return v;
    };

    const injectTextNodes = (graph) => {
        if (!graph || typeof graph !== "object") return graph;
        const g = graph;
        const setText = (nodeId, text) => {
            const n = g?.[nodeId];
            if (!n || typeof n !== "object") return false;
            if (!n.inputs || typeof n.inputs !== "object") n.inputs = {};
            if ("text" in n.inputs || n.class_type?.toLowerCase?.().includes("cliptextencode")) {
                n.inputs.text = String(text || "");
                return true;
            }
            return false;
        };

        let did = false;
        if (positiveNodeId) did = setText(positiveNodeId, promptText) || did;
        if (negativeNodeId) did = setText(negativeNodeId, negativePrompt) || did;
        if (did) return g;

        const clipNodes = Object.entries(g).filter(([_, n]) => /CLIPTextEncode/i.test(String(n?.class_type || "")));
        if (clipNodes.length) {
            const [id1] = clipNodes[0];
            setText(id1, promptText);
            if (clipNodes.length > 1) {
                const [id2] = clipNodes[1];
                setText(id2, negativePrompt);
            }
        }
        return g;
    };

    let graph = safeStructuredClone(baseGraph);
    graph = deepReplace(graph);
    graph = applyComfySettings(graph, { checkpoint, sampler, scheduler, steps, cfg, denoise, seed, width, height });
    graph = injectTextNodes(graph);

    try {
        for (const n of Object.values(graph || {})) {
            const ct = String(n?.class_type || "");
            if (!/KSampler/i.test(ct)) continue;
            if (!n.inputs || typeof n.inputs !== "object") n.inputs = {};
            const sd = Number(n.inputs.seed);
            if (!Number.isFinite(sd) || sd < 0) n.inputs.seed = seed;
        }
    } catch (_) {}

    const client_id = `uie_${Date.now().toString(16)}_${Math.floor(Math.random() * 1e9).toString(16)}`;
    const headers = { "Content-Type": "application/json" };
    if (apiKey) {
        headers.Authorization = `Bearer ${apiKey}`;
        headers["X-Api-Key"] = apiKey;
    }

    const proxyOpts = forceProxy ? { skipDirect: true } : {};
    const fx = await fetchWithCorsProxyFallback(promptUrl, {
        method: "POST",
        headers,
        body: JSON.stringify({ prompt: graph, client_id })
    }, proxyOpts);

    const res = fx.response;
    if (!res.ok) {
        const err = await res.text();
        console.error("ComfyUI Error:", err);
        try { window.UIE_lastImage = { ok: false, endpoint, mode: "comfy", status: res.status, error: String(err || res.statusText || "ComfyUI prompt failed").slice(0, 280), via: fx?.via }; } catch (_) {}
        if (window.toastr) toastr.error("ComfyUI prompt failed");
        return null;
    }
    const data = await res.json();
    const prompt_id = String(data?.prompt_id || "");
    if (!prompt_id) return null;

    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const deadline = Date.now() + 120_000;

    while (Date.now() < deadline) {
        await sleep(1000);
        let h;
        try {
            const hrFx = await fetchWithCorsProxyFallback(`${historyUrl}/${encodeURIComponent(prompt_id)}`, { method: "GET" }, proxyOpts);
            const hr = hrFx.response;
            if (!hr.ok) continue;
            h = await hr.json();
        } catch (_) {
            continue;
        }
        const job = h?.[prompt_id];
        const outputs = job?.outputs && typeof job.outputs === "object" ? job.outputs : null;
        if (!outputs) continue;

        const pickFromNode = (nodeId) => {
            const o = outputs?.[nodeId];
            const imgs = Array.isArray(o?.images) ? o.images : [];
            return imgs[0];
        };

        let target = null;
        if (outputNodeId) target = pickFromNode(outputNodeId);
        if (!target) {
            for (const k of Object.keys(outputs)) {
                target = pickFromNode(k);
                if (target) break;
            }
        }

        if (target) {
            const fname = target.filename;
            const sub = target.subfolder;
            const type = target.type;
            const query = `filename=${encodeURIComponent(fname)}&subfolder=${encodeURIComponent(sub)}&type=${encodeURIComponent(type)}`;
            const url = `${viewUrl}?${query}`;
            const r = await fetchWithCorsProxyFallback(url, { method: "GET" }, proxyOpts);
            const blob = await r.response.blob();
            return new Promise(resolve => {
                const reader = new FileReader();
                reader.onload = () => resolve(reader.result);
                reader.readAsDataURL(blob);
            });
        }
    }
    return null;
}

export async function populateImageSettings(baseUrl, ckSel, saSel, scSel) {
    if (ckSel) ckSel.innerHTML = `<option value="">Loading…</option>`;
    if (saSel) saSel.innerHTML = `<option value="">Loading…</option>`;
    if (scSel) scSel.innerHTML = `<option value="">Loading…</option>`;

    const s = getSettings();
    const det = await detectBackend(baseUrl);

    if (det.type === "comfy") {
        const info = det.info;
        const checkpoints = getComfyEnum(info, "CheckpointLoaderSimple", "ckpt_name");
        const samplers = getComfyEnum(info, "KSampler", "sampler_name");
        const schedulers = getComfyEnum(info, "KSampler", "scheduler");

        fillSelect(ckSel, checkpoints, s.image?.comfy?.checkpoint);
        fillSelect(saSel, samplers, s.image?.comfy?.sampler);
        fillSelect(scSel, schedulers, s.image?.comfy?.scheduler);
        if (window.toastr) toastr.success("Connected to ComfyUI!");
        return;
    }

    if (det.type === "a1111") {
        const opts = await loadA1111(baseUrl);
        fillSelect(ckSel, opts.checkpoints, s.image?.comfy?.checkpoint);
        fillSelect(saSel, opts.samplers, s.image?.comfy?.sampler);
        fillSelect(scSel, opts.schedulers.length ? opts.schedulers : ["karras","sgm_uniform","exponential","ddim_uniform","normal","beta","beta57"], s.image?.comfy?.scheduler);
        if (window.toastr) toastr.success("Connected to A1111/SD.Next!");
        return;
    }

    // Unknown backend
    const errMsg = `<option value="">(Couldn’t detect backend)</option>`;
    if (ckSel) ckSel.innerHTML = errMsg;
    if (saSel) saSel.innerHTML = errMsg;
    if (scSel) scSel.innerHTML = errMsg;
    if (window.toastr) toastr.warning("Could not detect ComfyUI or A1111 at that URL.");
}

// Dummy Implementations for Missing Functions
async function detectBackend(url) {
    // Basic detection logic
    try {
        const r = await fetchWithCorsProxyFallback(`${url}/system_stats`);
        if(r.response.ok) return { type: "comfy", info: await fetchObjectInfo(url) };
    } catch(_) {}

    try {
        const r = await fetchWithCorsProxyFallback(`${url}/sdapi/v1/options`);
        if(r.response.ok) return { type: "a1111" };
    } catch(_) {}

    return { type: "unknown" };
}

async function fetchObjectInfo(url) {
    try {
        const r = await fetchWithCorsProxyFallback(`${url}/object_info`);
        return await r.response.json();
    } catch(e) { return {}; }
}

async function loadA1111(url) {
    const out = { checkpoints: [], samplers: [], schedulers: [] };
    try {
        const r1 = await fetchWithCorsProxyFallback(`${url}/sdapi/v1/sd-models`);
        const d1 = await r1.response.json();
        out.checkpoints = d1.map(x => x.title);
    } catch(_) {}
    try {
        const r2 = await fetchWithCorsProxyFallback(`${url}/sdapi/v1/samplers`);
        const d2 = await r2.response.json();
        out.samplers = d2.map(x => x.name);
    } catch(_) {}
    return out;
}

function getComfyEnum(info, classType, field) {
    try {
        const def = info?.[classType]?.input?.required?.[field];
        if(Array.isArray(def) && Array.isArray(def[0])) return def[0];
    } catch(_) {}
    return [];
}

function fillSelect(sel, items, selected) {
    if(!sel) return;
    sel.innerHTML = "";
    items.forEach(i => {
        const opt = document.createElement("option");
        opt.value = i;
        opt.textContent = i;
        if(i === selected) opt.selected = true;
        sel.appendChild(opt);
    });
}

export function initImageUi() {
    const refreshUi = () => {
        const val = $("#uie-img-provider").val();
        $("#uie-img-openai-block").hide();
        $("#uie-img-comfy-block").hide();
        $("#uie-img-sdwebui-block").hide();

        if (val === "comfy") $("#uie-img-comfy-block").show();
        else if (val === "sdwebui") $("#uie-img-sdwebui-block").show();
        else if (val === "openai") $("#uie-img-openai-block").show();
    };

    const applySettingsToInputs = () => {
        const s = getSettings();
        const img = s.image || {};
        if (typeof img.enabled === "boolean") $("#uie-img-enable").prop("checked", img.enabled);
        if (img.provider) $("#uie-img-provider").val(img.provider);
        if (img.url) $("#uie-img-url").val(img.url);
        if (img.key) $("#uie-img-key").val(img.key);
        if (img.model) {
            $("#uie-img-model").val(img.model);
            if ($("#uie-img-model-select option[value='" + img.model + "']").length) {
                $("#uie-img-model-select").val(img.model);
            }
        }
        if (img.negativePrompt) $("#uie-img-negative").val(img.negativePrompt);
        if (img.sdwebuiUrl) $("#uie-img-sdwebui-url").val(img.sdwebuiUrl);
        if (img.comfy) {
            if (img.comfy.base) $("#uie-img-comfy-base").val(img.comfy.base);
            if (img.comfy.key) $("#uie-img-comfy-key").val(img.comfy.key);
            if (img.comfy.checkpoint) $("#uie-img-comfy-ckpt").val(img.comfy.checkpoint);
            if (img.comfy.quality) $("#uie-img-comfy-quality").val(img.comfy.quality);
            if (img.comfy.sampler) $("#uie-img-comfy-sampler").val(img.comfy.sampler);
            if (img.comfy.scheduler) $("#uie-img-comfy-scheduler").val(img.comfy.scheduler);
            if (img.comfy.common) $("#uie-img-comfy-common").val(img.comfy.common);
            if (img.comfy.commonNeg) $("#uie-img-comfy-common-neg").val(img.comfy.commonNeg);
            if (img.comfy.workflow) $("#uie-img-comfy-workflow").val(img.comfy.workflow);
            if (img.comfy.positiveNodeId) $("#uie-img-comfy-posnode").val(img.comfy.positiveNodeId);
            if (img.comfy.negativeNodeId) $("#uie-img-comfy-negnode").val(img.comfy.negativeNodeId);
            if (img.comfy.outputNodeId) $("#uie-img-comfy-outnode").val(img.comfy.outputNodeId);
        }
        $("#uie-img-url-adv").val(img.url || "");
        $("#uie-img-key-adv").val(img.key || "");
        $("#uie-img-model-adv").val(img.model || "");
    };

    const syncSetting = (updater) => {
        const s = getSettings();
        if (!s.image) s.image = {};
        updater(s.image);
        saveSettings();
    };

    const coerceNum = (v) => {
        const n = Number(v);
        return Number.isFinite(n) ? n : null;
    };

    const pickFirst = (...vals) => {
        for (const v of vals) {
            if (v === undefined || v === null) continue;
            if (typeof v === "string" && !v.trim()) continue;
            return v;
        }
        return null;
    };

    const readFromLocalStorage = () => {
        try {
            const keys = Object.keys(localStorage || {});
            const candidates = keys
                .filter(k => /comfy|comfyui|stable[_-]?diffusion|stablediffusion|sd[_-]?settings|sd[_-]?config|image[_-]?gen/i.test(String(k)))
                .slice(0, 40);
            for (const k of candidates) {
                let raw = "";
                try { raw = localStorage.getItem(k); } catch (_) { raw = ""; }
                if (!raw || raw.length < 2) continue;
                let obj = null;
                try { obj = JSON.parse(raw); } catch (_) { obj = null; }
                if (!obj || typeof obj !== "object") continue;
                const asStr = JSON.stringify(obj);
                if (!/8188|comfy|workflow|sampler|scheduler|cfg|denoise|checkpoint|ckpt/i.test(asStr)) continue;
                return obj;
            }
        } catch (_) {}
        return null;
    };

    const bestEffortExtract = (root) => {
        const out = {};
        if (!root || typeof root !== "object") return out;

        const comfy =
            root.comfy ||
            root.comfyui ||
            root.ComfyUI ||
            root.comfyUi ||
            root.stable_diffusion ||
            root.stablediffusion ||
            root.sd ||
            root.sdSettings ||
            root.sd_settings ||
            root.image ||
            root.imageGen ||
            root.image_generation ||
            null;

        const r = (comfy && typeof comfy === "object") ? comfy : root;

        out.base = pickFirst(r.base, r.base_url, r.baseUrl, r.url, r.endpoint, r.host, r.server, r.address);
        out.key = pickFirst(r.key, r.api_key, r.apiKey, r.token, r.auth, r.authorization);
        out.checkpoint = pickFirst(r.checkpoint, r.ckpt, r.ckpt_name, r.model, r.model_name);
        out.sampler = pickFirst(r.sampler, r.sampler_name, r.sampling_method, r.samplingMethod);
        out.scheduler = pickFirst(r.scheduler, r.schedule, r.scheduling, r.sigma_schedule);
        out.steps = pickFirst(r.steps, r.sampling_steps, r.samplingSteps);
        out.cfg = pickFirst(r.cfg, r.cfg_scale, r.cfgScale, r.guidance_scale, r.guidanceScale);
        out.width = pickFirst(r.width, r.w, r.image_width, r.imageWidth);
        out.height = pickFirst(r.height, r.h, r.image_height, r.imageHeight);
        out.denoise = pickFirst(r.denoise, r.denoising_strength, r.denoisingStrength, r.strength);
        out.seed = pickFirst(r.seed, r.random_seed, r.randomSeed);
        out.common = pickFirst(r.common, r.common_prompt, r.commonPrompt, r.prompt_prefix, r.promptPrefix);
        out.commonNeg = pickFirst(r.commonNeg, r.common_negative, r.commonNegative, r.negative_prefix, r.negativePrefix);
        out.negativePrompt = pickFirst(r.negativePrompt, r.negative_prompt, r.negativePromptText, r.negative);
        out.workflow = pickFirst(r.workflow, r.workflow_json, r.workflowJson);

        return out;
    };

    const importFromSillyTavern = () => {
        const roots = [];
        try { roots.push(window.extension_settings || null); } catch (_) { roots.push(null); }
        try { roots.push(window.settings || null); } catch (_) { roots.push(null); }
        try { roots.push(window.SillyTavern || null); } catch (_) { roots.push(null); }
        try { roots.push(readFromLocalStorage()); } catch (_) { roots.push(null); }

        let merged = {};
        for (const root of roots) {
            const ex = bestEffortExtract(root);
            merged = { ...merged, ...Object.fromEntries(Object.entries(ex).filter(([,v]) => v !== null && v !== undefined && !(typeof v === "string" && !v.trim()))) };
        }

        const hasAny = Object.keys(merged).length > 0;
        if (!hasAny) return null;

        const cleanUrl = (u) => {
            const s = String(u || "").trim();
            if (!s) return "";
            if (/^https?:\/\//i.test(s)) return s;
            return `http://${s}`;
        };

        return {
            base: merged.base ? cleanUrl(merged.base) : "",
            key: merged.key ? String(merged.key) : "",
            checkpoint: merged.checkpoint ? String(merged.checkpoint) : "",
            sampler: merged.sampler ? String(merged.sampler) : "",
            scheduler: merged.scheduler ? String(merged.scheduler) : "",
            steps: coerceNum(merged.steps),
            cfg: coerceNum(merged.cfg),
            width: coerceNum(merged.width),
            height: coerceNum(merged.height),
            denoise: coerceNum(merged.denoise),
            seed: coerceNum(merged.seed),
            common: merged.common ? String(merged.common) : "",
            commonNeg: merged.commonNeg ? String(merged.commonNeg) : "",
            negativePrompt: merged.negativePrompt ? String(merged.negativePrompt) : "",
            workflow: merged.workflow ? String(merged.workflow) : ""
        };
    };

    $(document).off("change.uieImg").on("change.uieImg", "#uie-img-provider", function() {
        syncSetting((img) => { img.provider = $(this).val(); });
        refreshUi();
    });

    $(document).off("change.uieImgComfyImport").on("change.uieImgComfyImport", "#uie-img-comfy-import", function(e) {
        e.preventDefault();
        e.stopPropagation();
        const val = String($(this).val() || "").trim();
        if (!val) return;
        $(this).val("");
        if (val !== "st") return;

        const imported = importFromSillyTavern();
        if (!imported) {
            try { window.toastr?.warning?.("No SillyTavern image settings found to import."); } catch (_) {}
            return;
        }

        const s = getSettings();
        if (!s.image) s.image = {};
        if (!s.image.comfy) s.image.comfy = {};
        if (!s.image.comfy.easy) s.image.comfy.easy = {};

        if (imported.base) {
            s.image.provider = "comfy";
            s.image.url = imported.base;
            s.image.comfy.base = imported.base;
            $("#uie-img-provider").val("comfy");
            $("#uie-img-url").val(imported.base);
            $("#uie-img-comfy-base").val(imported.base);
        }
        if (imported.key) {
            s.image.comfy.key = imported.key;
            $("#uie-img-comfy-key").val(imported.key);
        }
        if (imported.checkpoint) { s.image.comfy.checkpoint = imported.checkpoint; $("#uie-img-comfy-ckpt").val(imported.checkpoint); }
        if (imported.sampler) { s.image.comfy.sampler = imported.sampler; $("#uie-img-comfy-sampler").val(imported.sampler); }
        if (imported.scheduler) { s.image.comfy.scheduler = imported.scheduler; $("#uie-img-comfy-scheduler").val(imported.scheduler); }
        if (imported.common) { s.image.comfy.common = imported.common; $("#uie-img-comfy-common").val(imported.common); }
        if (imported.commonNeg) { s.image.comfy.commonNeg = imported.commonNeg; $("#uie-img-comfy-common-neg").val(imported.commonNeg); }
        if (imported.negativePrompt) { s.image.negativePrompt = imported.negativePrompt; $("#uie-img-negative").val(imported.negativePrompt); }
        if (imported.workflow) { s.image.comfy.workflow = imported.workflow; $("#uie-img-comfy-workflow").val(imported.workflow); }

        if (imported.steps !== null) { s.image.comfy.easy.steps = String(imported.steps); $("#uie-img-comfy-steps").val(String(imported.steps)); }
        if (imported.cfg !== null) { s.image.comfy.easy.cfg = String(imported.cfg); $("#uie-img-comfy-cfg").val(String(imported.cfg)); }
        if (imported.width !== null) { s.image.comfy.easy.width = String(imported.width); $("#uie-img-comfy-width").val(String(imported.width)); }
        if (imported.height !== null) { s.image.comfy.easy.height = String(imported.height); $("#uie-img-comfy-height").val(String(imported.height)); }
        if (imported.denoise !== null) { s.image.comfy.easy.denoise = String(imported.denoise); $("#uie-img-comfy-denoise").val(String(imported.denoise)); }
        if (imported.seed !== null) { s.image.comfy.easy.seed = String(imported.seed); $("#uie-img-comfy-seed").val(String(imported.seed)); }

        saveSettings();
        refreshUi();
        try { window.toastr?.success?.("Imported ComfyUI settings from SillyTavern."); } catch (_) {}
    });

    $(document).off("change.uieImgEnable").on("change.uieImgEnable", "#uie-img-enable", function() {
        syncSetting((img) => { img.enabled = $(this).is(":checked"); });
    });

    $(document).off("input.uieImgUrl change.uieImgUrl").on("input.uieImgUrl change.uieImgUrl", "#uie-img-url, #uie-img-url-adv", function() {
        const val = String($(this).val() || "").trim();
        syncSetting((img) => { img.url = val; });
    });

    $(document).off("input.uieImgKey change.uieImgKey").on("input.uieImgKey change.uieImgKey", "#uie-img-key, #uie-img-key-adv", function() {
        const val = String($(this).val() || "").trim();
        syncSetting((img) => { img.key = val; });
    });

    $(document).off("change.uieImgModelSelect").on("change.uieImgModelSelect", "#uie-img-model-select", function() {
        const val = String($(this).val() || "").trim();
        if (val && val !== "__custom__") {
            $("#uie-img-model").val(val);
            syncSetting((img) => { img.model = val; });
        }
    });

    $(document).off("input.uieImgModel change.uieImgModel").on("input.uieImgModel change.uieImgModel", "#uie-img-model, #uie-img-model-adv", function() {
        const val = String($(this).val() || "").trim();
        syncSetting((img) => { img.model = val; });
    });

    $(document).off("input.uieImgNeg change.uieImgNeg").on("input.uieImgNeg change.uieImgNeg", "#uie-img-negative", function() {
        const val = String($(this).val() || "").trim();
        syncSetting((img) => { img.negativePrompt = val; });
    });

    $(document).off("input.uieImgSd change.uieImgSd").on("input.uieImgSd change.uieImgSd", "#uie-img-sdwebui-url", function() {
        const val = String($(this).val() || "").trim();
        syncSetting((img) => { img.sdwebuiUrl = val; });
    });

    $(document).off("input.uieImgComfy change.uieImgComfy").on("input.uieImgComfy change.uieImgComfy", "#uie-img-comfy-base, #uie-img-comfy-key, #uie-img-comfy-ckpt, #uie-img-comfy-quality, #uie-img-comfy-sampler, #uie-img-comfy-scheduler, #uie-img-comfy-common, #uie-img-comfy-common-neg, #uie-img-comfy-workflow, #uie-img-comfy-posnode, #uie-img-comfy-negnode, #uie-img-comfy-outnode, #uie-img-comfy-steps, #uie-img-comfy-cfg, #uie-img-comfy-width, #uie-img-comfy-height, #uie-img-comfy-denoise, #uie-img-comfy-seed", function() {
        const s = getSettings();
        if (!s.image) s.image = {};
        if (!s.image.comfy) s.image.comfy = {};
        if (!s.image.comfy.easy) s.image.comfy.easy = {};
        s.image.comfy.base = String($("#uie-img-comfy-base").val() || "").trim();
        s.image.comfy.key = String($("#uie-img-comfy-key").val() || "").trim();
        s.image.comfy.checkpoint = String($("#uie-img-comfy-ckpt").val() || "").trim();
        s.image.comfy.quality = String($("#uie-img-comfy-quality").val() || "").trim();
        s.image.comfy.sampler = String($("#uie-img-comfy-sampler").val() || "").trim();
        s.image.comfy.scheduler = String($("#uie-img-comfy-scheduler").val() || "").trim();
        s.image.comfy.common = String($("#uie-img-comfy-common").val() || "").trim();
        s.image.comfy.commonNeg = String($("#uie-img-comfy-common-neg").val() || "").trim();
        s.image.comfy.workflow = String($("#uie-img-comfy-workflow").val() || "").trim();
        s.image.comfy.positiveNodeId = String($("#uie-img-comfy-posnode").val() || "").trim();
        s.image.comfy.negativeNodeId = String($("#uie-img-comfy-negnode").val() || "").trim();
        s.image.comfy.outputNodeId = String($("#uie-img-comfy-outnode").val() || "").trim();
        s.image.comfy.easy.steps = String($("#uie-img-comfy-steps").val() || "").trim();
        s.image.comfy.easy.cfg = String($("#uie-img-comfy-cfg").val() || "").trim();
        s.image.comfy.easy.width = String($("#uie-img-comfy-width").val() || "").trim();
        s.image.comfy.easy.height = String($("#uie-img-comfy-height").val() || "").trim();
        s.image.comfy.easy.denoise = String($("#uie-img-comfy-denoise").val() || "").trim();
        s.image.comfy.easy.seed = String($("#uie-img-comfy-seed").val() || "").trim();
        saveSettings();
    });

    $(document).off("click.uieImgComfyApply").on("click.uieImgComfyApply", "#uie-img-comfy-apply", function(e) {
        e.preventDefault();
        e.stopPropagation();

        const s = getSettings();
        if (!s.image) s.image = {};
        if (!s.image.comfy) s.image.comfy = {};
        if (!s.image.comfy.easy) s.image.comfy.easy = {};

        const base = String($("#uie-img-comfy-base").val() || "").trim();
        if (!base) {
            try { window.toastr?.warning?.("Enter ComfyUI URL first"); } catch (_) {}
            return;
        }

        const q = String($("#uie-img-comfy-quality").val() || "balanced");
        const defaults = q === "fast" ? { w: 512, h: 512, steps: 16 } : q === "hq" ? { w: 1024, h: 1024, steps: 32 } : { w: 768, h: 768, steps: 24 };
        if (!String($("#uie-img-comfy-width").val() || "").trim()) $("#uie-img-comfy-width").val(String(defaults.w));
        if (!String($("#uie-img-comfy-height").val() || "").trim()) $("#uie-img-comfy-height").val(String(defaults.h));
        if (!String($("#uie-img-comfy-steps").val() || "").trim()) $("#uie-img-comfy-steps").val(String(defaults.steps));
        if (!String($("#uie-img-comfy-cfg").val() || "").trim()) $("#uie-img-comfy-cfg").val("7");
        if (!String($("#uie-img-comfy-denoise").val() || "").trim()) $("#uie-img-comfy-denoise").val("1");
        if (!String($("#uie-img-comfy-seed").val() || "").trim()) $("#uie-img-comfy-seed").val("-1");

        s.image.provider = "comfy";
        s.image.url = base;
        s.image.comfy.base = base;

        if (!String(s.image.comfy.workflow || "").trim()) {
            s.image.comfy.workflow = buildDefaultComfyWorkflowJson();
        }

        // Let auto-detect handle these unless the user explicitly set them.
        if (!String(s.image.comfy.positiveNodeId || "").trim()) s.image.comfy.positiveNodeId = "";
        if (!String(s.image.comfy.negativeNodeId || "").trim()) s.image.comfy.negativeNodeId = "";
        if (!String(s.image.comfy.outputNodeId || "").trim()) s.image.comfy.outputNodeId = "";

        // Trigger the shared sync handler
        $("#uie-img-provider").val("comfy");
        $("#uie-img-url").val(base);
        $("#uie-img-comfy-workflow").val(String(s.image.comfy.workflow || ""));
        $("#uie-img-comfy-base, #uie-img-comfy-quality, #uie-img-comfy-steps, #uie-img-comfy-cfg, #uie-img-comfy-width, #uie-img-comfy-height, #uie-img-comfy-denoise, #uie-img-comfy-seed").trigger("change");
        saveSettings();
        refreshUi();
        try { window.toastr?.success?.("Applied ComfyUI Easy Setup"); } catch (_) {}
    });

    $(document).off("click.uieImgTest").on("click.uieImgTest", "#uie-img-test", async function(e) {
        e.preventDefault();
        e.stopPropagation();

        const out = await generateImageAPI("[UIE_LOCKED] A cinematic fantasy illustration of a traveler in a lantern-lit forest, ultra-detailed, sharp focus");
        if (!out) {
            const last = window.UIE_lastImage;
            const err = last?.error ? String(last.error).slice(0, 120) : "Unknown error";
            const hint = last?.mode === "comfy" ? " For ComfyUI, enable a CORS proxy in SillyTavern or run ComfyUI with --allow-cors."
                : "";
            try { window.toastr?.error?.(`Test image failed: ${err}${hint}`); } catch (_) {}
            return;
        }
        const id = "uie-img-test-modal";
        $("#" + id).remove();
        const html = `
            <div id="${id}" style="position:fixed; inset:0; z-index:2147483660; background:rgba(0,0,0,0.85); display:flex; align-items:center; justify-content:center;">
                <div style="background:#111; border:1px solid rgba(255,255,255,0.2); padding:12px; border-radius:12px; width:min(820px, 94vw); max-height:92vh; overflow:auto;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:10px;">
                        <div style="color:#fff; font-weight:700;">UIE Image Test</div>
                        <button style="background:#333; border:1px solid #555; color:#fff; padding:6px 10px; border-radius:8px; cursor:pointer;" onclick="$('#${id}').remove()">Close</button>
                    </div>
                    <img src="${String(out)}" style="width:100%; height:auto; border-radius:10px; display:block;" />
                </div>
            </div>
        `;
        $("body").append(html);
    });

    $(document).off("click.uieImgRefresh").on("click.uieImgRefresh", "#uie-img-comfy-ckpt-refresh", function(e) {
        e.preventDefault();
        const url = $("#uie-img-comfy-base").val();
        if(!url) return toastr.warning("Enter ComfyUI URL first");
        populateImageSettings(url,
            document.getElementById("uie-img-comfy-ckpt"),
            document.getElementById("uie-img-comfy-sampler"),
            document.getElementById("uie-img-comfy-scheduler")
        );
    });

    const applyImgPreset = () => {
        const p = $("#uie-img-preset").val();
        if(p === "nanogpt") {
            $("#uie-img-url").val("https://nano-gpt.com/api/v1/images/generations");
            $("#uie-img-model-select").val("hidream");
            $("#uie-img-model").val("hidream");
            $("#uie-img-key").val("");
            if(window.toastr) toastr.success("Applied NanoGPT Preset");
        } else if (p === "openai") {
            $("#uie-img-url").val("https://api.openai.com/v1/images/generations");
            $("#uie-img-model-select").val("dall-e-3");
            $("#uie-img-model").val("dall-e-3");
            if(window.toastr) toastr.success("Applied OpenAI Preset");
        }
        $("#uie-img-url").trigger("change");
    };

    $(document).off("click.uieImgPreset").on("click.uieImgPreset", "#uie-img-preset-apply", function(e) {
        e.preventDefault();
        e.stopPropagation();
        applyImgPreset();
    });
    // Auto-apply on change as well
    $(document).off("change.uieImgPreset").on("change.uieImgPreset", "#uie-img-preset", function(e) {
        e.preventDefault();
        e.stopPropagation();
        applyImgPreset();
    });

    // Initial State
    const s = getSettings();
    if (s.image?.provider) $("#uie-img-provider").val(s.image.provider);
    applySettingsToInputs();
    refreshUi();
}
